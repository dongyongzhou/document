---
layout: master
title: Understanding Linux Kernel
---

## 参考


## 系统调用

用户态切换到内核态方法：

中断、异常、系统调用

### 定义

系统调用： 操作系统用户态进程与硬件设备进行交互的一组接口

当用户态进程调用一个系统调用时，CPU切换到内核态并开始执行一个内核函数。

系统调用通过软中断实现

封装例程(wrapper routine，唯一目的就是发布系统调用， 一般每个系统调用对应一个封装例程

API：库再用这些封装例程定义出给用户的API，API只是一个函数定义

### 调用过程

应用程序->封装例程->系统调用处理程序->系统调用服务例程

### 传参 
   
系统调用也需要输入输出参数

- 实际的值： system_call是linux中所有系统调用的入口点，每个系统调用至少有一个参数，即系统调用号
由**使用eax寄存器**传递

- 用户态进程地址空间的变量的地址
- 甚至是包含指向用户态函数的指针的数据结构的地址

**实现方法：**

在系统调用汇编指令之前，系统调用的参数被写入CPU的寄存器。然后，在进入内核态调用系统调用服务例程之前，内核再把存放在CPU寄存器中的参数拷贝到内核态堆栈中。因为毕竟服务例程是C函数，它还是要到堆栈中去寻找参数的

**使用寄存器传递参数具有如下限制：**

1）每个参数的长度不能超过寄存器的长度，即32位

2）在系统调用号（eax）之外，参数的个数不能超过6个（ebx，ecx，edx，esi，edi，ebp）
？超过6个怎么办？

**验证参数**

在内核打算满足用户的请求之前，必须仔细的检查所有的系统调用参数

1） 如write()系统调用，fd参数是一个文件描述符，sys_write()必须检查这个fd是否确实是以前已打开文件的一个文件描述符，进程是否有向fd指向的文件的写权限，如果有条件不成立，那这个处理程序必须返回一个负数

2） 只要一个参数指定的是地址，那么内核必须检查它是否在这个进程的地址空间之内，有两种验证方法：

a 验证这个线性地址是否属于进程的地址空间(费时. 大多数情况下，不必要)

b 仅仅验证这个线性地址小于PAGE_OFFSET(高效. 可以在后续的执行过程中，很自然的捕获到出错的情况. 从linux2.2开始执行第二种检查)

在内核中，可以访问到所有的内存, **要防止用户将一个内核地址作为参数传递给内核**，这将导致它借用内核代码来读写任意内存

### 传递返回值

服务例程的返回值是将会被写入eax寄存器中

这个是在执行“return”指令时，由编译器自动完成的

### 系统调用号

内核利用了一个系统调用分派表(dispatch table)。
这个表存放在sys_call_table数组中，有若干个表项(2.6.26中，是356)：

第n个表项对应了系统调用号为n的服务例程的入口地址的指针


### 访问进程的地址空间

系统调用服务例程需要非常频繁的读写进程地址空间的数据

get_user/put_user/ copy_to_user/ copy_from_user etc.

内核对进程传递的地址参数只进行粗略的检查

**访问进程地址空间时的缺页**，可以有多种情况

- 合理的缺页：来自虚存技术. 页框不存在或者写时复制
- 由于错误引起的缺页(内核对进程传递的地址参数只进行粗略的检查)
- 由于非法引起的缺页

**非法缺页的判定**

内核中，只有少数几个函数/宏会访问用户地址空间

对于一次非法缺页，一定来自于这些函数/宏

可以将访问用户地址空间的指令的地址一一列举出来，当发生非法缺页时，根
据引起出错的指令地址来定位

在缺页异常do_page_fault中，若最后发现是非法缺页，就会执行下面的操作->找到修正代码

## Linux Time

### 定时测量

- 获得当前的时间和日期.
系统调用：time(), ftime()以及gettimeofday()
- 维持定时器
settimer(), alarm()

### 定时的硬件设备

硬件电路: 基于固定频率振荡器和计数器

硬时钟

1, 实时时钟Real time clock，RTC

Linux本身只使用RTC获得时间和日期

对应的设备文件为/dev/rtc

2, 时间戳计数器Time stamp counter，TSC

外：在80x86微处理器中，有一个CLK输入引线.接收外部振荡器的时钟信号

内：很多80x86微处理器都引入了一个TSC（一个64位的、用作时间戳计数器的寄存器）

它在每个时钟信号（CLK）到来时+1

rdtsc指令用于读该寄存器

Linux中

Linux在系统初始化的时候必须**确定时钟信号CLK的频率**（即CPU的实际频率）

tsc_calibrate(根据在一个相对较长的时间间隔内（约5ms）所发生的TSC计数的个数进行计算)

那个间隔由可编程间隔定时器给出

3, 可编程间隔定时器Programmable interval timer, PIT

经过适当编程后，可以周期性的给出时钟中断

通常是8254 CMOS芯片

Linux将PIT编程为：
100Hz、1000Hz,
通过IRQ0发出时钟中断,
每若干毫秒（100Hz为10ms）产生一次时钟中断，即一个tick

4, CPU本地定时器
5, 高精度事件定时器
6, ACPI电源管理定时器

### Linux的计时体系结构

- 更新自系统启动以来所经过的时间
- 更新时间和日期
- 确定当前进程的执行时间，考虑是否要抢占
- 更新资源使用统计计数
- 检查到期的软定时器

在单处理器系统中，所有定时活动都由IRQ0上的时钟中断触发，包括

- 在中断中立即执行的部分，和
- 作为下半部分延迟执行的部分

### 计时体系结构中的关键数据结构和变量

- 系统时钟system timer

时钟中断发生源

- Jiffies变量

记录系统自启动以来系统产生的tick数, 每次时钟中断＋1

jiffies，32位.约50天就溢出

关于jiffies_64.数十亿年才会溢出

- 计时时钟源

时钟源抽象,参见数据结构clocksource

是系统时钟源，定义了系统时钟源的接口

缺省时钟源,Jiffies时钟源

- Xtime变量

存放当前时间和日期

时间纪元: 1970年1月1日（UTC）午夜

基本上每个tick更新一次,根据时钟源来更新xtime的秒数和纳秒数



### Linux内核中与时间有关的程序

timer_interrupt->do_timer_interrupt_hook

a->do_timer(jiffies)->update_times(Xtime)

b->update_process_times

### 实现CPU分时、更新系统时间、维护软定时器

定时器是一种软件功能，它允许在将来的某个时刻调用某个函数

大多数设备驱动程序利用定时器完成一些特殊工作

由于软定时器在下半部分处理，内核不能保证定时器正好在时钟到期的时候被执行，会存在延迟，不适用于实时应用


Linux中存在两类定时器：

1， 动态定时器.内核使用(驱动常用)

动态定时器被动态的创建和撤销，当前活动的动态定时器个数没有限制

创建并激活一个动态定时器

- 创建一个新的timer_list对象
- 调用init_timer初始化，并设置定时器要处理的函数和参数
- 设置定时时间
- 使用add_timer加入到合适的链表中
- 通常定时器只能执行一次，如果要周期性的执行，必须再次将其加入链表


动态定时器应用之delayed work

动态定时器应用之schedule_timeout

延迟函数： udelay, ndelay

2， 间隔定时器.由进程在用户态创建

### 与定时测量相关的系统调用及相关服务例程

**与定时测量相关的系统调用**

- time()
:返回从1970年1月1日凌晨0点开始的秒数
- ftime()
:返回从1970年1月1日凌晨0点开始的秒数以及最后一秒的毫秒数
数据结构为timeb
- gettimeofday()
:返回从1970年1月1日凌晨0点开始的秒数
,对应于sys_gettimeofday()
- settimer()
:间隔定时器
,频率：周期性的触发定时器（若为0，只触发一次）
- alarm()
: 引起SIGALARM信号

**与时钟相关的命令**

date：显示或者更改系统时钟

使用time获得时钟

使用ctime改变时钟格式

## 内存管理

### 1，Overview

RAM的某些部分永久地分配给内核，用以存放内核代码以及静态数据

RAM的其余部分称为动态存储器（dynamic memory）

进程和内核都需要动态存储器

整个系统的性能取决于如何有效地管理动态存储器，原则：按需分配，不需要时释放

### 2，页框管理

Linux内存管理的基本单位：页

Linux采用的标准的页框大小：4KB（4KB是大多数磁盘块大小的倍数。传输效率高，管理方便）

**2.1 页框管理工作：**

内核必须记录每个页框的当前状态

- 哪些属于进程，哪些存放了内核代码/数据
- 对于动态存储器中的页框：是否空闲，即是否可用
- 如果一个页框不可用，内核需要知道是谁在用这个页框
（用户态进程、动态分配的内核数据结构、静态的内核代码、页面cache、设备驱动程序缓冲的数据等等）

内核使用**页描述符**来跟踪管理**物理内存**

- 每个物理页框都用一个页描述符表示
- 页描述符用struct page的结构描述(mm_types.h)
- 所有物理页框的描述符，组织在mem_map的数组中

由于每个struct page结构小于64个字节,页描述符将会占用很大的一段空间

**2.2 node **

物理内存被划分为若干个node.存取时间不等,考虑CPU局部性

Node使用数据结构pg_data_t描述

每个node被划分成若干个zone

** 存储区(Memory Zones)**

划分原因：

一些页框由于自身的物理地址的原因不能被一些任务所使用，例如
：ISA总线的DMA控制器只能对ram的前16M寻址
；在一些具有大容量ram的32位计算机中，CPU不能直接访问所有的物理存储器，因为线性地址空间不够

为了应付这种限制，Linux把具有同样性质的物理内存划分成——区(zones)

每个zone使用struct zone表示

Linux把物理存储器划分为4个区

- ZONE_DMA：包含存储器的“常规”页，通过把它们映射到线性地址空间的3GB以上，内核就可直接访问
- ZONE_DMA32  (未见用）
- ZONE_NORMAL：包含存储器的“常规”页，通过把它们映射到线性地址空间的3GB以上，内核就可直接访问
- ZONE_HIGHMEM：中包含的存储器页面不能由内核直接访问

**2.3 请求页框接口 **

- 分配：
alloc_pages/alloc_page/alloc_pages_node/alloc_pages_current/…/__get_free_pages/__get_free_page/__get_dma_pages/get_zeroed_page
- 释放：
free_pages/__free_pages/free_page/__free_page


**2.4 页框的管理**

内核要为分配一组连续的页框建立一种稳定、高效的分配策略(要解决（外部）碎片问题)

**2.5 避免碎片办法：**

- 利用MMU把一组非连续的物理空闲页框映射到连续的线性地址空间
- 使用一种适当的技术来记录现存的空闲连续页框的情况，以尽量避免为满足对小块的请求而把大块的空闲块进行分割

Linux内核首选第二种方法，**原因**

- 在某些情况下，必须使用连续的页框，如DMA
- 尽量少的修改内核页表


**2.6 buddy算法（伙伴算法，Linux使用）**

把所有空闲页框分组为10（Linux2.6.26为11）个块链表，每个块链表分别包含大小为1，2，4，8，16，32，64，128，256和512个连续的页框

每个块的第一个页框的物理地址是该块大小的整数倍。例如：大小为16个页框的块，其起址是16×4KB的倍数

两个伙伴的大小必须相同，物理地址必须连续
。假定伙伴的大小为b
，那么第一个伙伴的物理地址必须是2×b×4KB对齐

事实上伙伴是通过对大块的物理内存划分获得的

Linux为每个zone使用各自独立的伙伴系统

主要数据结构

- 空闲内存管理数组free_area。
空闲内存按照伙伴管理的方法进行组织；
使用free_area结构

**伙伴**

当两个伙伴都为空闲的时候，就合并成一个更大的块。
该过程将一直进行，直到找不到可以合并的伙伴为止

寻找伙伴

- 给定一个要释放的空闲块
- 找到其伙伴
- 查看其状态：合并 or 不合并

**内存分配**

假设要请求一个大小为128个页框的块(0.5MB)。

- 算法先free_area[7]中检查是否有空闲块（块大小为128个页框）
- 若没有，就到free_area[8]中找一个空闲块（块大小为256个页框）
- 若存在这样的块，内核就把256个页框分成两等份，一半用作满足请求，另一半插入free_area[7]中
- 如果在free_area[8]中也没有空闲块，就继续找free_area[9]中是否有空闲块。	
- 若有，先将512分成伙伴，一个插入free_area[8]中，另一个进一步划分成伙伴，取其一插入free_area[7]中，另一个分配出去
- 如果free_area[9]也没有空闲块，内存不够，返回一个错误信号

**内存的分配与回收**

__free_pages->__free_pages_ok->free_one_page

__alloc_pages->__alloc_pages_internal->get_page_from_freelist->buffered_rmqueue

### 3 内存区管理(memory area)

内核中大量使用各种数据结构，大小从几个字节到几十上百k不等，都取整到2的幂次个页面那是完全不现实的 

**3.1 早期内核解决方法**

**早期内核**的解决方法是提供大小为2,4,8,16,...,131056字节的内存区域 

需要新的内存区域时，内核从伙伴系统申请页面，把它们划分成一个个区域，取一个来满足需求 

如果某个页面中的内存区域都释放了，页面就交回到伙伴系统 

**3.2 Linux2.6.26中**

**SLOB Allocator**: Simple List Of Blocks.
**Slub**：slab的一个变种

slab分配器把内存区看成**对象**

slab分配器把对象**分组**放进高速缓存。

每个**高速缓存**都是同种类型内存对象的一种“储备”

例如当一个文件被打开时，存放相应“打开文件”对象所需的内存是从一个叫做filp(file pointer)的slab分配器的高速缓存中得到的
也就是说每种对象类型对应一个高速缓存

每个高速缓存被分成多个slabs，每个slab由一个或多个连续的页框组成，其中包含一定数目的对象

每个slab有三种状态：全满，半满，全空

- 全满意味着slab中的对象全部已被分配出去
- 全空意味着slab中的对象全部是可用的
- 半满介于两者之间

当内核函数需要一个新的对象时，

- 优先从半满的slab满足这个请求
- 否则从全空的slab中取一个对象满足请求
- 如果没有空的slab则向buddy系统申请页面生成一个新的slab

**普通和专用高速缓存**

每个高速缓存使用kmem_cache表示

普通高速缓存根据大小分配内存

- 26个，2组（一组用于DMA分配，另一组用于常规分配）
- 每组13个，大小从25=32个字节，到217=132017个字节
- 数据结构cache_sizes
- 数组：malloc_sizes

专用高速缓存根据	类型分配


**slab分配器提供的接口**

- 创建专用高速缓存：kmem_cache_create
- 撤销专用高速缓存：kmem_cache_destroy
一般内核撤销一个模块时会调用这个函数撤销属于那个模块的cache类型
- 从专用高速缓冲中分配和释放.
从高速缓存中分配/释放一个内存对象
kmem_cache_alloc/kmem_cache_free
- 从普通高速缓存中分配和释放
**kmalloc/kfree**

slab分配器调用kmem_getpages()来获取一组连续的空闲页框

相应的有kmem_freepages()来释放分配给slab分配器的页框

如果编写的**内核模块有许多创建和释放数据结构**的操作，可以考虑调用前面所述的**slab分配器的接口创建一个高速缓存**
	这样可以大大减少内存的访问时间

### 4 非连续存储区管理

把线性空间映射到一组连续的页框是很好的选择

有时候不得不将线性空间映射到一组不连续的页框.优点：避免碎片

Linux内核有为非连续内存区保留的线性地址空间（VMALLOC_START~VMALLOC_END）

非连续存储区的描述符vm_struct

Vmalloc等分配一个非连续存储区

Vfree释放非连续线性区间

总结：

- alloc_pages/free_page:buddy算法，分配大空间
- kmalloc/kfree：slab，分配数据结构
- Vmalloc/Vfree: 非连续内存区

## 进程地址空间

进程最多能访问**4GB**的线性地址空间

但进程在访问某个线性空间之前，必须获得该**线性空间的许可**

因此，一个**进程的地址空间**是**由允许该进程访问的全部线性地址**组成

内核使用**线性区资源**来表示线性地址空间

每个线性区由起**始线性地址、长度和一些存取权限**描述

线性区的开始和结束都必须**4KB对齐**

进程**获得新线性区**的一些典型情况：

- 刚刚创建的新进程
- 使用exec系统调用装载一个新的程序运行
- 将一个文件（或部分）映射到进程地址空间中
- 当用户堆栈不够用的时候，扩展堆栈对应的线性区
……


### 1 内核态和用户态分配内存的不同

**内核态**

内核中的函数以**直接了当的方式**获得动态内存

- 内核是操作系统中优先级最高的成分。
- 内核信任自己
- 采用**页面级内存分配**和**小内存分配**

**用户态**

给用户态进程分配内存时，请求被认为是不紧迫的，用户进程不可信任

当用户态进程请求动态内存时，并**没有立即获得实际的物理页框**，而仅仅**获得对一个新的线性地址区间的使用权**

这个线性地址区间会成为进程地址空间的一部分，称作**线性区(memory areas)**


### 2 线性区（memory area）

比如0x08048000——0x0804C000这段线性地址空间被分配给了一个进程，进程就可以访问这段地址空间

进程只能访问某个有效的memory area。进一步讲，这个area可以被标志为只读或者不可执行(nonexecutable)

如果进程试图访问一个有效的area之外的地址或者用不正确的方式访问一个有效的area，内核将通过**段异常(segmentation fault)**杀死这个进程

**线性区中可以包含各种内容**

- 可执行文件代码段的内存映射，就是.text section
- 数据段的内存映射，.data section
- zero page的内存映射用来包含未初始化的全局变量，.bss section
- 为库函数和链接器附加的代码、数据、bss段
- 文件的内存映射
- 共享内存的映射
- 匿名内存区域的映射，比如通过malloc()函数申请的内存区域

进程地址空间中所有有效的线性地址都确定的存在于一个area中，
memory areas不重叠

进程中每个单独的area对应一个不同内存区：
堆栈、二进制代码、全局变量、文件映射等等


每个线性区由一个**vm_area_struct结构**来表示

- 这个结构描述了一段给定的内存区间
- 区间中的地址都有同样的属性，比如同样的存取权限和相关的操作函数
- 用这个结构可以表示各种线性区，比如映射可执行的二进制代码的线形区、用作用户态堆栈的线形区等等

线性区的存取权限

vm_flags域描述有关这个线性区全部页的信息。例如，进程访问每个页的权限是什么。还有一些标志描述线性区自身，例如它应该如何增长

- VM_READ, VM_WRITE, VM_EXEC
- VM_SHARED
- VM_RESERVED
- VM_GROWSUP

线性区的链表和红黑树

- 通过内存描述符中的两个域mmap和mm_rb都可以访问线性区。事实上，它们都指向了同一个vm_area_struct结构，只是链接的方式不同

- mmap指向的线性区链表用来遍历整个进程的地址空间
- 红黑树mm_rb用来定位一个给定的线性地址落在进程地址空间中的哪一个线性区中
- mmap_cache用来缓存最近用过的线性区


处理线性区

(内核进程需要对一个线性区进行处理，比如确定一个给定线性地址是否存在于一个线性地址空间中)

- find_vma()，查找一个线性地址
 两个参数：进程内存描述符的地址mm和线性地址addr
- find_vma_intersection()，查找一个与给定地址区间重叠的线性区
- get_unmapped_area()，查找一个空闲的地址区间
arch_get_unmapped_area,
shm_get_unmapped_area
- insert_vm_struct()，向内存描述符链表中插入一个线性区

- mmap()和do_mmap()，创建一个线性区
- munmap()和do_munmap(),
do_munmap()函数从进程地址空间中删除一段线性空间

### 3 缺页异常（i386中14号异常）

如前所述，内核只是通过mmap()等调用**分配了一些线性地址空间**给进程，并没有真正的把实际的物理页框分配给进程

当进程试图访问这些分配给它的地址空间时，比如一段线性地址空间映射的是二进制代码，则进程被调度执行的时候会跳转到这个地址上去执行。

此时，并没有物理页框对应于这些线性地址，从而会引发一个缺页异常

缺页异常处理程序处理缺页异常。

缺页异常处理程序do_page_fault

- 它可以判断出这是不是一个合法的缺页异常，如果是，则负责给这段线性地址分配一些物理页框并把磁盘中对应的文件写入这些物理页框

- 这样进程得以正常运行。

## 程序的执行

操作系统是如何通过可执行文件的内容建立进程的执行上下文的？

程序以可执行文件的形式存放在磁盘上

库(静态库   vs    共享库)可供很多程序使用的一些例程的集合

命令行参数、环境变量等

### 1 可执行文件

可执行文件是一个普通的文件，它描述了如何初始化一个新的进程上下文

Fork + execve

用户使用shell来执行某个程序时，可以指定命令行参数

Shell本身不限制命令行参数的个数，但它受限于命令自身

**库**

源文件->目标文件->可执行文件

最小的程序也会利用到C库

    例如：void main(void) {}
    要为main的执行建立执行上下文
    在进程结束时，杀死进程（在main的最后插入exit()）


**静态链接 vs 动态链接**

静态链接: 静态库.Gcc的-static选项指明使用静态库

动态链接：共享库

**程序段和进程的线性区**

在逻辑上，Unix程序的线性地址空间被划分为各种段（segment）

- 正文段，text
- 数据段，data
- Bss段
- 堆栈段

此外，还有共享库和文件的映射，他们映射在其他线性区


### 2 可执行格式

Linux标准的可执行格式 ELF：Executable and Linking Format

旧版的可执行文件格式 a.out：Assembler OUT put format

其他 MS-DOS的exe文件, UNIX BSD的COFF文件

**Linux对可执行文件格式的处理**

在系统启动时，所有编译进内核的可执行格式都被注册: register_binfmt/unregister_binfmt

在系统运行过程中，也可以注册一个新的可执行文件格式

使用linux_binfmt对象管理

Linux通过可执行文件的**扩展名**或者存放在**文件前128字节的magic数**来识别文件格式

### 3 Exec函数
 
系统调用：execve->sys_execve

do_execve->search_binary_handler(找到一个可以识别执行文件的handler)->load_binary(对于elf格式的文件：load_elf_binary)

do_execve->open_exec

用一个指定的可执行文件所描述的上下文代替进程的上下文

## 文件系统

### 1 Unix文件系统概述

** 1.1 文件**

Unix文件是以*字节序列*组成的信息载体

内核不解释文件的内容

文件的组织

文件被组织成一个树状的命名空间

- 文件：叶结点
- 目录：根节点（根目录“/”）和中间节点
; 目录使用一个目录名标识。
; 目录节点包含它下面的文件及子目录的所有信息

文件名和目录名

- 不能使用“/”和字符“\0”，其他ASCII字符都OK
- 长度：不同的文件系统有不同的限制，通常<256个字符
- 同一个目录下，不允许文件重名；不同目录下无妨

当前工作目录

Unix的每个进程都有一个当前工作目录，current working directory，属于进程的执行上下文 

绝对路径：用来在命名空间中指定一个特定的文件，以“/”打头，表示以根目录作为起点，\形如
“/home/chenxl/sample/test.c”

相对路径：以当前工作目录作为起点
例如当前目录为“/home/chenxl”，则上述文件的相对路径可以是“sample/test.c”

“.”和“..”

- 前者表示当前工作目录
- 后者表示当前工作目录的父目录
- 若当前工作目录是根目录“/”，那么“.”和“..”相等

** 2 硬链接和软链接**

**硬链接（hard link）**

- 一般情况下，一个常见的文件名代表了到对应文件的一个硬链接
- 一个文件可以有不同的硬链接，他们可以在同一个目录下，也可以在不同的目录下，因此一个文件可以有不同的文件名
- 下面的命令可以创建一个硬链接.其中p1指明一个现有的文件的路径名,p2指明新建立的硬链接的路径名

    $ ln p1 p2 

硬链接的限制

- 不允许用户给目录创建硬链接
- 只有在同一个文件系统的文件之间才能创建硬链接

**软链接（symbolic link）**

- 符号链接是一种特殊的文件（短文件），它包含另一个文件的任意一个路径名
- 可以指向任意一个文件系统的任意文件，甚至一个不存在的文件
- 下面的命令可以创建一个软链接.p2指明新建立的软连接的路径名。在实现上，文件系统抽出p2的目录部分，在此目录下创建一个符号链接文件

    $ ln -s p1 p2 

** 3 文件类型**

Unix文件的类型可以是

- 基本类型:常规文件（regular file）、目录、符号链接
- 设备和驱动相关:面向块的设备文件、面向字符的设备文件
- 用于进程间通信：管道和命名管道、套接字

** 4 文件描述符与索引节点**

文件系统处理文件所需要的所有信息都包含在索引节点inode中

每个文件都有自己的inode

一般而言，inode应当包含如下信息

- 文件类型
- 与文件相关的硬链接的个数
- 以字节为单位的文件的长度
- 设备标识符（即包含文件的设备的标识符）
- 在文件系统中标识文件的inode号
- 文件拥有者的UID
- 文件的GID
- 一些时间戳：inode状态的改变时间、文件的最后访问时间、最后修改时间
- 访问权限和文件模式

** 5 访问权限和文件模式**

文件潜在的用户分为3种类型

- 文件所有者
- 同组用户
- 其他用户

访问权限：读、写、执行


每类用户都有这三种权限
文件的访问权限使用9个不同的bit来表示

此外还有三种附加标记
suid、sgid、sticky

- Suid：运行该文件时，将以文件所有者的权限来运行，如果文件所有者是root的，容易成为漏洞

执行某个可执行文件的时候，进程通常具有进程拥有者的UID，但是若可执行文件设置了SUID标记，则进程将拥有文件所有者的UID

- Sgid：只对目录有效，在这个目录下创建的所有文件拥有与目录所属组相同的组

进程的GID将不是进程拥有者的GID，而是文件所有者所在组的GID

- Sticky：例如tmp目录下的文件，只有文件所有者能够删除。

告诉内核，就算一个程序运行结束了，也暂时将程序保留在内存中

在一个文件被创建的时候：

- 一个文件的属主UID就是创建这个文件的进程的UID
- 一个文件的属主GID可能是：
创建这个文件的进程的GID
、若文件的父目录设置了SGID标记，则该文件将继承父目录的GID


** 6 文件操作的系统调用**

- 打开/关闭int open(const char *pathname, int flags);
- 打开/关闭int open(const char *pathname, int flags, mode_t mode);
- 创建int creat(const char *pathname, mode_t mode); 
- 读/写ssize_t write(int fd, const void *buf, size_t count); 
- 删除int unlink(const char *pathname);
- 定位off_t lseek(int fildes, off_t offset, int whence); 
- 更名int rename(const char *oldpath, const char *newpath); 


### 2 Linux的虚拟文件系统

** 2.1 虚拟文件系统VFS的作用**

VFS是一个软件层，用来处理与Unix标准文件系统相关的所有系统调用。
是用户应用程序与文件系统实现之间的抽象层

能为各种文件系统提供一个通用的、统一的接口

Linux与其他类Unix系统一样，采用虚拟文件系统VFS来达到支持多种文件系统格式的目标

**VFS在一个简单文件复制操作中的作用**

从一种文件系统复制到另一文件系统。对于cp命令而言，它不需要知道/floppy/TEST和/tmp/test分别是什么文件系统类型。它通过VFS提供的系统调用接口进行文件操作

**2.2 VFS支持的文件系统类型**

- 基于磁盘的文件系统：它们管理在本地磁盘分区中可用的存储空间

    Linux使用的文件系统：ext2、ext3、ReiserFS
    Unix家族的文件系统：SYSV文件系统，UFS，MINIX文件系统以及VERITAS VxFS
    微软公司的文件系统：MS-DOS、VFAT以及NTFS
    ISO9660CD-ROM文件系统和通用磁盘格式的DVD文件系统
    其他有专利权的文件系统，如HPFS、HFS、AFFS、ADFS
    起源于非Linux系统的其他日志文件系统，JFS，XFS

- 网络文件系统：用于访问属于其他网络计算机的文件系统所包含的文件

    NFS、Coda、AFS、SMB、NCP

- 特殊文件系统

    不同于上述两大类
    不管理具体的磁盘空间
    /proc

各种不同的文件系统通过mount（挂载、安装）到根文件系统中

- 在Linux中，根文件系统即根目录所代表的文件系统
- 通常是ext2文件系统

VFS的基本思想：引入一个**通用文件模型**，这个模型能够表示所有支持的文件系统

- 对于一个具体实现的文件系统，在处理时，需要将其进行概念上的转换,
例如，在通用文件模型中，目录被看成是普通文件
- 在实现上，
   	read()->sys_read->file数据结构->f_op->MS_DOS文件操作指针（其中的read操作）
- 类似面向对象的概念

**2.3 通用文件模型有下列对象类型组成**

- 超级块对象（superblock object）
存放文件系统相关信息：例如文件系统控制块
- 索引节点对象（inode object）
存放具体文件的一般信息：文件控制块/inode
- 文件对象（file object）
存放已打开的文件和进程之间交互的信息
- 目录项对象（dentry object）
存放目录项与文件的链接信息

**2.4 VFS所处理的系统调用**

- mount、umount：挂载/卸载文件系统
- sysfs ：获取文件系统信息
- statfs、fstatfs、ustat ：获取文件系统统计信息
- chroot ：更改根目录
- chdir、fchdir、getcwd ：操纵当前工作目录
- mkdir、rmdir ：创建/删除目录
- getdents、readdir 、link 、unlink 、rename ：对目录项进行操作
- readlink 、symlink ：对软链接进行操作
- chown 、fchown 、lchown ：更改文件所有者
- chmod 、fchmod 、utime ：更改文件属性
- open、close、create …

上述大部分操作之需要与通用文件模型中的一些对象打交道，而不需要真正操作具体的文件系统和文件，因此可以把VFS看成是一个“通用”的文件系统，在必要时依赖某种具体的文件系统


**2.5 VFS的数据结构**

**2.5.1 一个具体的文件系统：**超级块对象：super_block****

- 所有超级块链表：super_blocks ：s_list域
- 文件系统特有信息：s_fs_info域，例如ext2_sb_info
- 脏标志：s_dirt域
- 文件系统特有方法s_op：super_operations数据结构及域，例如ext2_sops

每种文件系统具有自己的super_block结构

每个文件系统具有一个所属文件系统类型的super_block实例

**2.5.2 一个具体的文件：Inode对象：inode**

Inode特有的方法 inode_operations

文件特有的方法 file_operations

**2.5.3 目录项对象：dentry**

目录项操作：dentry_operations

**2.5.4 一个打开文件：文件对象：file**

文件操作指针f_pos

文件对象特有的方法

专用高速缓存：“filp”，filp_cachep 

**2.5.5 与进程相关的文件**

文件系统相关信息fs_struct

打开文件相关信息files_struct

** 2.6 文件系统类型**

**特殊文件系统**

用来为系统程序员、系统管理员等提供一种容易的方式来操作内核的数据结构并实现操作系统的特殊特征

procfs / sysfs etc.

**常用的特殊文件系统**

文件系统类型的注册.在系统初始化期间，register_filesystem()用来注册编译时指定的每个文件系统
相应的文件系统对象被插入到file_systems链表中



** 2.7 文件系统安装**

文件系统的挂载

一个文件系统的根目录是系统目录树的根目录，那个这个文件系统就是根文件系统

** 2.8 路径名查找**

标准查找操作

父路径名的查找

符号链接的查找
** 2.9 VFS系统调用的实现**

xxx->sys_xxx

open->sys_open

** 2.10 文件加锁**

当多个进程访问同一个文件时，会出现同步问题:写同一个文件的同一个位置、
对同一个文件的同一个位置，1读1写、
或者更复杂的情况

Unix提供对文件的加锁机制，可避免上述冲突。
POSIX标准规定了基于fcntl()系统调用的文件加锁机制

- 强制锁  vs  劝告锁

劝告锁（advisory lock）：需要进程主动参与
Fcntl、flock、lockf

强制锁（mandatory lock）：内核强制检查

- 读锁  vs  写锁

读锁：多个进程可以读共享

写锁：只能一个进程写，并且与读锁互斥


**Linux支持所有的文件加锁方式**

### 3 Ext2文件系统简介

EXT2文件系统是EXT文件系统的升级，在Linux中得到了广泛的使用。

**3.1 EXT2文件系统的磁盘组织**

除了引导扇区之外，EXT2磁盘分区被顺序划分为若干个**磁盘块组（Block Group）。**

每个块组由若干个**磁盘块**，按照相同的方式组织，具有相同的大小。

**EXT2磁盘块组**中的磁盘块按顺序被组织成：

- 一个用作**超级块**的磁盘块。
在这个磁盘块里，存放了文件系统超级块的一个拷贝；

多个块组中的超级块形成冗余。在某个或少数几个超级块被破坏时，可用于恢复被破坏的超级块信息。

- N个记录**组描述符**的磁盘块；

组描述符用来描述一个磁盘块组的相关信息

- 1个记录**数据块位图**的磁盘块；
- 1个记录**索引结点位图**的磁盘块；

EXT2中所有的索引结点大小相同，都是128个字节。 

- N个用作**索引结点表**的磁盘块；

EXT2的一个磁盘块组中的索引结点存储在一组连续的磁盘块中，形成一个索引结点表。 

这组磁盘块中的第一个磁盘块的块号存储在超级块的bg_inode_table数据项中。

根据磁盘块的大小，可以计算出每个磁盘块能容纳多少个索引结点

根据索引结点的总个数，可以计算出索引结点表所需要占用的磁盘块的个数。  


关于索引节点中的i_block[]

ext2的索引结点中使用了组合索引方式。 

    前12项用作直接索引
    第13项用作间接索引
    第14项用作二次间接索引
    第15项用作三次间接索引 

- N个用作**数据块**的磁盘块。

EXT2的空闲盘块分配算法采用了位图法

每个位（bit）都对应了一个磁盘块

2个位图分别占用一个专门的磁盘块。

根据磁盘块的大小，可以计算出每个块组中最多能容纳的数据块个数和索引节点块个数。  

**3.2 EXT2文件系统的目录项和支持的文件类型**

在EXT2中，目录是一种特殊的文件，这种文件的数据块中存放了该目录下的所有目录项 

EXT2在目录项中存放了**文件的类型信息**。文件类型可以是0～7中的任意一个整数。它们分别代表如下含义：

    0：文件类型未知；
    1：普通文件类型；
    2：目录；
    3：字符设备；
    4：块设备；
    5：有名管道FIFO；
    6：套接字；
    7：符号链接。

**3.3 创建一个ext2文件系统**

mke2fs的缺省参数

    磁盘块大小：1024字节
    分片：目前不支持，因此与磁盘块一样
    分配inode的个数：1/8192B
    永久保留的块的个数：5％

创建流程

- 初始化超级块和组描述符
- Optionally, 检查是否有坏块，若有创建坏块列表
- 对每个块组，保留所有用来存放超级块、组描述符、inode表、2个位图的磁盘块
- 初始化每个块组中的位图
- 初始化每个块组中的inode表
- 创建 /root 目录
- 创建 lost+found 目录（供e2fsck 使用，与坏块相关）
- 为上述两个目录而更新位图信息
- 若有坏块，则将其在 lost+found 目录中组织起来

**3.4 Ext2提供的各种对象方法**

超级块对象方法：super、inode write ...

索引节点对象方法:设置属性，目录rmdir mkdir 等

文件对象方法：read write open

**3.5 管理ext2的磁盘空间**

涉及到如下操作：

    创建/删除一个索引节点
    数据块的寻址
    文件空洞
    分配/释放一个数据块

**文件内块号 vs. 逻辑块号**

根据数据在文件中的偏移可以计算逻辑块号：

- 首先计算出文件内块号 ＝（偏移f－1）/块大小的商 ＋1 
- 根据索引信息，查询到逻辑块号

**文件空洞:**

A file hole is a portion of a regular file that contains null characters and is not stored in any data block on disk

文件空洞可以节省磁盘空间

Ext2通过数据块的**动态分配**来实现这一点：**当且仅当一个进程要写数据到文件中的时候才真正分配磁盘块**

## 进程间同步和通信

###1 进程间通信(IPC，Inter-Process Communication)

Unix系统提供的基本的IPC包括：

- 1、管道和FIFO（有名管道）
- 2、消息
- 3、信号量
- 4、共享内存区
- 5、套接字

**1.1 管道（pipe）**

管道是半双工的，数据只能向一个方向流动；
  
    一个进程将数据写入管道，另一个进程从管道中读取数据
    数据的读出和写入：写入的内容每次都添加在管道**缓冲区**的末尾，每次都是从缓冲区的头部读出数据.

需要双方通信时，需要建立起两个管道；

只能用于**父子进程或者兄弟进程**之间（具有亲缘关系的进程）； 

在shell中使用管道的例子: |(前输出到后输入) >（输出重定向） <（输入重定向）

管道可看成是被打开的文件，但并没有真实的文件与之对应

**创建一个管道**

pipe()系统调用用来创建一个新的管道

    #include <unistd.h>
    int pipe(int filedes[2]);

- filedes[0]只能用于读，称为管道读端；
- filedes[1]只能用于写，称为管道写端。
- 若试图从写端读，或者向读端写都将导致错误发生。

一般文件的I/O函数都可用于管道，如close、read、write等

管道只能在具有亲缘关系的进程之间进行通信，通过fork传递管道的描述符


管道的一个重大限制是它没有名字，因此只能用于具有亲缘关系的进程间通信

**1.2` 有名管道（named pipe或FIFO）**

特殊的文件类型：

- 1，严格遵循先入先出的读写规则
- 2，类似管道，在文件系统中不存在数据块，而是与一块**内核缓冲区**相关联
- 3，有名字，FIFO的名字包含在**系统的目录树结构**中，可以按名访问

**FIFO的操作**

mkfifo


fopen fwrite fclose fread 

以及：open，close，read，write等普通文件操作


**1.2 消息队列**

消息队列就是一个消息的**链表**

可以把消息看作一个记录，具有特定的格式以及特定的**优先级**。

对消息队列有写权限的进程可以按照一定的规则向消息队列**添加新消息**；

对消息队列有读权限的进程则可以**从消息队列中读走消**息。 

消息队列的创建

    int msgget(key_t key, int msgflg) 

发送消息

    int msgsnd(int msqid, 	//目标消息队列
        struct msgbuf *msgp, 	//待发送的消息
        int msgsz, 			//消息的大小
        int msgflg); 			//标志

接收消息

    int msgrcv(int msqid, //msqid为消息队列描述字
        struct msgbuf *msgp, //消息返回后存储这里
        int msgsz,	//指定消息内容的长度
        long msgtyp,	//请求读取的消息类型
        int msgflg); 

消息队列的其他操作

    int msgctl(int msqid, int cmd, struct msqid_ds *buf); 

**1.3 信号量**

Semphore，用来对**资源**进行**并发控制访问**

semop用来获取或释放信号量对应的资源

**1.4 共享内存**

允许两个或多个进程通过把公共数据放入一个共享内存区来访问它们

shmget：获得或创建一个共享内存区的IPC标志符

shmctl:控制 

shmat : 将一个共享内存区“附加”到一个进程上，
使得进程可以访问共享内存区的内容
进程通过shmaddr指定并获得共享内
存区在该进程中的起始地址

shmdt: 将指定位置的共享内存区从进程中分离出去

**1.5 套接字socket**

套接字不仅可以用来实现网络间的进程通信，也可以用来实现本地的进程间通信

相关调用包括：

    Socket
    Listen
    Bind
    Connect/accept
    Send/recv，read/write
    Close
    …



Others

