---
layout: master
title: Understanding Linux Kernel
---

## 参考


## 系统调用

用户态切换到内核态方法：

中断、异常、系统调用

### 定义

系统调用： 操作系统用户态进程与硬件设备进行交互的一组接口

当用户态进程调用一个系统调用时，CPU切换到内核态并开始执行一个内核函数。

系统调用通过软中断实现

封装例程(wrapper routine，唯一目的就是发布系统调用， 一般每个系统调用对应一个封装例程

API：库再用这些封装例程定义出给用户的API，API只是一个函数定义

### 调用过程

应用程序->封装例程->系统调用处理程序->系统调用服务例程

### 传参 
   
系统调用也需要输入输出参数

- 实际的值： system_call是linux中所有系统调用的入口点，每个系统调用至少有一个参数，即系统调用号
由**使用eax寄存器**传递

- 用户态进程地址空间的变量的地址
- 甚至是包含指向用户态函数的指针的数据结构的地址

**实现方法：**

在系统调用汇编指令之前，系统调用的参数被写入CPU的寄存器。然后，在进入内核态调用系统调用服务例程之前，内核再把存放在CPU寄存器中的参数拷贝到内核态堆栈中。因为毕竟服务例程是C函数，它还是要到堆栈中去寻找参数的

**使用寄存器传递参数具有如下限制：**

1）每个参数的长度不能超过寄存器的长度，即32位

2）在系统调用号（eax）之外，参数的个数不能超过6个（ebx，ecx，edx，esi，edi，ebp）
？超过6个怎么办？

**验证参数**

在内核打算满足用户的请求之前，必须仔细的检查所有的系统调用参数

1） 如write()系统调用，fd参数是一个文件描述符，sys_write()必须检查这个fd是否确实是以前已打开文件的一个文件描述符，进程是否有向fd指向的文件的写权限，如果有条件不成立，那这个处理程序必须返回一个负数

2） 只要一个参数指定的是地址，那么内核必须检查它是否在这个进程的地址空间之内，有两种验证方法：

a 验证这个线性地址是否属于进程的地址空间(费时. 大多数情况下，不必要)

b 仅仅验证这个线性地址小于PAGE_OFFSET(高效. 可以在后续的执行过程中，很自然的捕获到出错的情况. 从linux2.2开始执行第二种检查)

在内核中，可以访问到所有的内存, **要防止用户将一个内核地址作为参数传递给内核**，这将导致它借用内核代码来读写任意内存

### 传递返回值

服务例程的返回值是将会被写入eax寄存器中

这个是在执行“return”指令时，由编译器自动完成的

### 系统调用号

内核利用了一个系统调用分派表(dispatch table)。
这个表存放在sys_call_table数组中，有若干个表项(2.6.26中，是356)：

第n个表项对应了系统调用号为n的服务例程的入口地址的指针


### 访问进程的地址空间

系统调用服务例程需要非常频繁的读写进程地址空间的数据

get_user/put_user/ copy_to_user/ copy_from_user etc.

内核对进程传递的地址参数只进行粗略的检查

**访问进程地址空间时的缺页**，可以有多种情况

- 合理的缺页：来自虚存技术. 页框不存在或者写时复制
- 由于错误引起的缺页(内核对进程传递的地址参数只进行粗略的检查)
- 由于非法引起的缺页

**非法缺页的判定**

内核中，只有少数几个函数/宏会访问用户地址空间

对于一次非法缺页，一定来自于这些函数/宏

可以将访问用户地址空间的指令的地址一一列举出来，当发生非法缺页时，根
据引起出错的指令地址来定位

在缺页异常do_page_fault中，若最后发现是非法缺页，就会执行下面的操作->找到修正代码

## Linux Time

### 定时测量

- 获得当前的时间和日期.
系统调用：time(), ftime()以及gettimeofday()
- 维持定时器
settimer(), alarm()

### 定时的硬件设备

硬件电路: 基于固定频率振荡器和计数器

硬时钟

1, 实时时钟Real time clock，RTC

Linux本身只使用RTC获得时间和日期

对应的设备文件为/dev/rtc

2, 时间戳计数器Time stamp counter，TSC

外：在80x86微处理器中，有一个CLK输入引线.接收外部振荡器的时钟信号

内：很多80x86微处理器都引入了一个TSC（一个64位的、用作时间戳计数器的寄存器）

它在每个时钟信号（CLK）到来时+1

rdtsc指令用于读该寄存器

Linux中

Linux在系统初始化的时候必须**确定时钟信号CLK的频率**（即CPU的实际频率）

tsc_calibrate(根据在一个相对较长的时间间隔内（约5ms）所发生的TSC计数的个数进行计算)

那个间隔由可编程间隔定时器给出

3, 可编程间隔定时器Programmable interval timer, PIT

经过适当编程后，可以周期性的给出时钟中断

通常是8254 CMOS芯片

Linux将PIT编程为：
100Hz、1000Hz,
通过IRQ0发出时钟中断,
每若干毫秒（100Hz为10ms）产生一次时钟中断，即一个tick

4, CPU本地定时器
5, 高精度事件定时器
6, ACPI电源管理定时器

### Linux的计时体系结构

- 更新自系统启动以来所经过的时间
- 更新时间和日期
- 确定当前进程的执行时间，考虑是否要抢占
- 更新资源使用统计计数
- 检查到期的软定时器

在单处理器系统中，所有定时活动都由IRQ0上的时钟中断触发，包括

- 在中断中立即执行的部分，和
- 作为下半部分延迟执行的部分

### 计时体系结构中的关键数据结构和变量

- 系统时钟system timer

时钟中断发生源

- Jiffies变量

记录系统自启动以来系统产生的tick数, 每次时钟中断＋1

jiffies，32位.约50天就溢出

关于jiffies_64.数十亿年才会溢出

- 计时时钟源

时钟源抽象,参见数据结构clocksource

是系统时钟源，定义了系统时钟源的接口

缺省时钟源,Jiffies时钟源

- Xtime变量

存放当前时间和日期

时间纪元: 1970年1月1日（UTC）午夜

基本上每个tick更新一次,根据时钟源来更新xtime的秒数和纳秒数



### Linux内核中与时间有关的程序

timer_interrupt->do_timer_interrupt_hook

a->do_timer(jiffies)->update_times(Xtime)

b->update_process_times

### 实现CPU分时、更新系统时间、维护软定时器

定时器是一种软件功能，它允许在将来的某个时刻调用某个函数

大多数设备驱动程序利用定时器完成一些特殊工作

由于软定时器在下半部分处理，内核不能保证定时器正好在时钟到期的时候被执行，会存在延迟，不适用于实时应用


Linux中存在两类定时器：

1， 动态定时器.内核使用(驱动常用)

动态定时器被动态的创建和撤销，当前活动的动态定时器个数没有限制

创建并激活一个动态定时器

- 创建一个新的timer_list对象
- 调用init_timer初始化，并设置定时器要处理的函数和参数
- 设置定时时间
- 使用add_timer加入到合适的链表中
- 通常定时器只能执行一次，如果要周期性的执行，必须再次将其加入链表


动态定时器应用之delayed work

动态定时器应用之schedule_timeout

延迟函数： udelay, ndelay

2， 间隔定时器.由进程在用户态创建

### 与定时测量相关的系统调用及相关服务例程

**与定时测量相关的系统调用**

- time()
:返回从1970年1月1日凌晨0点开始的秒数
- ftime()
:返回从1970年1月1日凌晨0点开始的秒数以及最后一秒的毫秒数
数据结构为timeb
- gettimeofday()
:返回从1970年1月1日凌晨0点开始的秒数
,对应于sys_gettimeofday()
- settimer()
:间隔定时器
,频率：周期性的触发定时器（若为0，只触发一次）
- alarm()
: 引起SIGALARM信号

**与时钟相关的命令**

date：显示或者更改系统时钟

使用time获得时钟

使用ctime改变时钟格式

## Others

Others

