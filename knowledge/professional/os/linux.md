---
layout: master
title: Understanding Linux Kernel
---

## 参考


## 系统调用

用户态切换到内核态方法：

中断、异常、系统调用

### 定义

系统调用： 操作系统用户态进程与硬件设备进行交互的一组接口

当用户态进程调用一个系统调用时，CPU切换到内核态并开始执行一个内核函数。

系统调用通过软中断实现

封装例程(wrapper routine，唯一目的就是发布系统调用， 一般每个系统调用对应一个封装例程

API：库再用这些封装例程定义出给用户的API，API只是一个函数定义

### 调用过程

应用程序->封装例程->系统调用处理程序->系统调用服务例程

### 传参 
   
系统调用也需要输入输出参数

- 实际的值： system_call是linux中所有系统调用的入口点，每个系统调用至少有一个参数，即系统调用号
由**使用eax寄存器**传递

- 用户态进程地址空间的变量的地址
- 甚至是包含指向用户态函数的指针的数据结构的地址

**实现方法：**

在系统调用汇编指令之前，系统调用的参数被写入CPU的寄存器。然后，在进入内核态调用系统调用服务例程之前，内核再把存放在CPU寄存器中的参数拷贝到内核态堆栈中。因为毕竟服务例程是C函数，它还是要到堆栈中去寻找参数的

**使用寄存器传递参数具有如下限制：**

1）每个参数的长度不能超过寄存器的长度，即32位

2）在系统调用号（eax）之外，参数的个数不能超过6个（ebx，ecx，edx，esi，edi，ebp）
？超过6个怎么办？

**验证参数**

在内核打算满足用户的请求之前，必须仔细的检查所有的系统调用参数

1） 如write()系统调用，fd参数是一个文件描述符，sys_write()必须检查这个fd是否确实是以前已打开文件的一个文件描述符，进程是否有向fd指向的文件的写权限，如果有条件不成立，那这个处理程序必须返回一个负数

2） 只要一个参数指定的是地址，那么内核必须检查它是否在这个进程的地址空间之内，有两种验证方法：

a 验证这个线性地址是否属于进程的地址空间(费时. 大多数情况下，不必要)

b 仅仅验证这个线性地址小于PAGE_OFFSET(高效. 可以在后续的执行过程中，很自然的捕获到出错的情况. 从linux2.2开始执行第二种检查)

在内核中，可以访问到所有的内存, **要防止用户将一个内核地址作为参数传递给内核**，这将导致它借用内核代码来读写任意内存

### 传递返回值

服务例程的返回值是将会被写入eax寄存器中

这个是在执行“return”指令时，由编译器自动完成的

### 系统调用号

内核利用了一个系统调用分派表(dispatch table)。
这个表存放在sys_call_table数组中，有若干个表项(2.6.26中，是356)：

第n个表项对应了系统调用号为n的服务例程的入口地址的指针


### 访问进程的地址空间

系统调用服务例程需要非常频繁的读写进程地址空间的数据

get_user/put_user/ copy_to_user/ copy_from_user etc.

内核对进程传递的地址参数只进行粗略的检查

**访问进程地址空间时的缺页**，可以有多种情况

- 合理的缺页：来自虚存技术. 页框不存在或者写时复制
- 由于错误引起的缺页(内核对进程传递的地址参数只进行粗略的检查)
- 由于非法引起的缺页

**非法缺页的判定**

内核中，只有少数几个函数/宏会访问用户地址空间

对于一次非法缺页，一定来自于这些函数/宏

可以将访问用户地址空间的指令的地址一一列举出来，当发生非法缺页时，根
据引起出错的指令地址来定位

在缺页异常do_page_fault中，若最后发现是非法缺页，就会执行下面的操作->找到修正代码
## Others

Others

