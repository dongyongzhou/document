---
layout: master
title: Understanding Linux Kernel
---

## 参考


## 系统调用

用户态切换到内核态方法：

中断、异常、系统调用

### 定义

系统调用： 操作系统用户态进程与硬件设备进行交互的一组接口

当用户态进程调用一个系统调用时，CPU切换到内核态并开始执行一个内核函数。

系统调用通过软中断实现

封装例程(wrapper routine，唯一目的就是发布系统调用， 一般每个系统调用对应一个封装例程

API：库再用这些封装例程定义出给用户的API，API只是一个函数定义

### 调用过程

应用程序->封装例程->系统调用处理程序->系统调用服务例程

### 传参 
   
系统调用也需要输入输出参数

- 实际的值： system_call是linux中所有系统调用的入口点，每个系统调用至少有一个参数，即系统调用号
由**使用eax寄存器**传递

- 用户态进程地址空间的变量的地址
- 甚至是包含指向用户态函数的指针的数据结构的地址

**实现方法：**

在系统调用汇编指令之前，系统调用的参数被写入CPU的寄存器。然后，在进入内核态调用系统调用服务例程之前，内核再把存放在CPU寄存器中的参数拷贝到内核态堆栈中。因为毕竟服务例程是C函数，它还是要到堆栈中去寻找参数的

**使用寄存器传递参数具有如下限制：**

1）每个参数的长度不能超过寄存器的长度，即32位

2）在系统调用号（eax）之外，参数的个数不能超过6个（ebx，ecx，edx，esi，edi，ebp）
？超过6个怎么办？

**验证参数**

在内核打算满足用户的请求之前，必须仔细的检查所有的系统调用参数

1） 如write()系统调用，fd参数是一个文件描述符，sys_write()必须检查这个fd是否确实是以前已打开文件的一个文件描述符，进程是否有向fd指向的文件的写权限，如果有条件不成立，那这个处理程序必须返回一个负数

2） 只要一个参数指定的是地址，那么内核必须检查它是否在这个进程的地址空间之内，有两种验证方法：

a 验证这个线性地址是否属于进程的地址空间(费时. 大多数情况下，不必要)

b 仅仅验证这个线性地址小于PAGE_OFFSET(高效. 可以在后续的执行过程中，很自然的捕获到出错的情况. 从linux2.2开始执行第二种检查)

在内核中，可以访问到所有的内存, **要防止用户将一个内核地址作为参数传递给内核**，这将导致它借用内核代码来读写任意内存

### 传递返回值

服务例程的返回值是将会被写入eax寄存器中

这个是在执行“return”指令时，由编译器自动完成的

### 系统调用号

内核利用了一个系统调用分派表(dispatch table)。
这个表存放在sys_call_table数组中，有若干个表项(2.6.26中，是356)：

第n个表项对应了系统调用号为n的服务例程的入口地址的指针


### 访问进程的地址空间

系统调用服务例程需要非常频繁的读写进程地址空间的数据

get_user/put_user/ copy_to_user/ copy_from_user etc.

内核对进程传递的地址参数只进行粗略的检查

**访问进程地址空间时的缺页**，可以有多种情况

- 合理的缺页：来自虚存技术. 页框不存在或者写时复制
- 由于错误引起的缺页(内核对进程传递的地址参数只进行粗略的检查)
- 由于非法引起的缺页

**非法缺页的判定**

内核中，只有少数几个函数/宏会访问用户地址空间

对于一次非法缺页，一定来自于这些函数/宏

可以将访问用户地址空间的指令的地址一一列举出来，当发生非法缺页时，根
据引起出错的指令地址来定位

在缺页异常do_page_fault中，若最后发现是非法缺页，就会执行下面的操作->找到修正代码

## Linux Time

### 定时测量

- 获得当前的时间和日期.
系统调用：time(), ftime()以及gettimeofday()
- 维持定时器
settimer(), alarm()

### 定时的硬件设备

硬件电路: 基于固定频率振荡器和计数器

硬时钟

1, 实时时钟Real time clock，RTC

Linux本身只使用RTC获得时间和日期

对应的设备文件为/dev/rtc

2, 时间戳计数器Time stamp counter，TSC

外：在80x86微处理器中，有一个CLK输入引线.接收外部振荡器的时钟信号

内：很多80x86微处理器都引入了一个TSC（一个64位的、用作时间戳计数器的寄存器）

它在每个时钟信号（CLK）到来时+1

rdtsc指令用于读该寄存器

Linux中

Linux在系统初始化的时候必须**确定时钟信号CLK的频率**（即CPU的实际频率）

tsc_calibrate(根据在一个相对较长的时间间隔内（约5ms）所发生的TSC计数的个数进行计算)

那个间隔由可编程间隔定时器给出

3, 可编程间隔定时器Programmable interval timer, PIT

经过适当编程后，可以周期性的给出时钟中断

通常是8254 CMOS芯片

Linux将PIT编程为：
100Hz、1000Hz,
通过IRQ0发出时钟中断,
每若干毫秒（100Hz为10ms）产生一次时钟中断，即一个tick

4, CPU本地定时器
5, 高精度事件定时器
6, ACPI电源管理定时器

### Linux的计时体系结构

- 更新自系统启动以来所经过的时间
- 更新时间和日期
- 确定当前进程的执行时间，考虑是否要抢占
- 更新资源使用统计计数
- 检查到期的软定时器

在单处理器系统中，所有定时活动都由IRQ0上的时钟中断触发，包括

- 在中断中立即执行的部分，和
- 作为下半部分延迟执行的部分

### 计时体系结构中的关键数据结构和变量

- 系统时钟system timer

时钟中断发生源

- Jiffies变量

记录系统自启动以来系统产生的tick数, 每次时钟中断＋1

jiffies，32位.约50天就溢出

关于jiffies_64.数十亿年才会溢出

- 计时时钟源

时钟源抽象,参见数据结构clocksource

是系统时钟源，定义了系统时钟源的接口

缺省时钟源,Jiffies时钟源

- Xtime变量

存放当前时间和日期

时间纪元: 1970年1月1日（UTC）午夜

基本上每个tick更新一次,根据时钟源来更新xtime的秒数和纳秒数



### Linux内核中与时间有关的程序

timer_interrupt->do_timer_interrupt_hook

a->do_timer(jiffies)->update_times(Xtime)

b->update_process_times

### 实现CPU分时、更新系统时间、维护软定时器

定时器是一种软件功能，它允许在将来的某个时刻调用某个函数

大多数设备驱动程序利用定时器完成一些特殊工作

由于软定时器在下半部分处理，内核不能保证定时器正好在时钟到期的时候被执行，会存在延迟，不适用于实时应用


Linux中存在两类定时器：

1， 动态定时器.内核使用(驱动常用)

动态定时器被动态的创建和撤销，当前活动的动态定时器个数没有限制

创建并激活一个动态定时器

- 创建一个新的timer_list对象
- 调用init_timer初始化，并设置定时器要处理的函数和参数
- 设置定时时间
- 使用add_timer加入到合适的链表中
- 通常定时器只能执行一次，如果要周期性的执行，必须再次将其加入链表


动态定时器应用之delayed work

动态定时器应用之schedule_timeout

延迟函数： udelay, ndelay

2， 间隔定时器.由进程在用户态创建

### 与定时测量相关的系统调用及相关服务例程

**与定时测量相关的系统调用**

- time()
:返回从1970年1月1日凌晨0点开始的秒数
- ftime()
:返回从1970年1月1日凌晨0点开始的秒数以及最后一秒的毫秒数
数据结构为timeb
- gettimeofday()
:返回从1970年1月1日凌晨0点开始的秒数
,对应于sys_gettimeofday()
- settimer()
:间隔定时器
,频率：周期性的触发定时器（若为0，只触发一次）
- alarm()
: 引起SIGALARM信号

**与时钟相关的命令**

date：显示或者更改系统时钟

使用time获得时钟

使用ctime改变时钟格式

## 内存管理

### 1，Overview

RAM的某些部分永久地分配给内核，用以存放内核代码以及静态数据

RAM的其余部分称为动态存储器（dynamic memory）

进程和内核都需要动态存储器

整个系统的性能取决于如何有效地管理动态存储器，原则：按需分配，不需要时释放

### 2，页框管理

Linux内存管理的基本单位：页

Linux采用的标准的页框大小：4KB（4KB是大多数磁盘块大小的倍数。传输效率高，管理方便）

**2.1 页框管理工作：**

内核必须记录每个页框的当前状态

- 哪些属于进程，哪些存放了内核代码/数据
- 对于动态存储器中的页框：是否空闲，即是否可用
- 如果一个页框不可用，内核需要知道是谁在用这个页框
（用户态进程、动态分配的内核数据结构、静态的内核代码、页面cache、设备驱动程序缓冲的数据等等）

内核使用**页描述符**来跟踪管理**物理内存**

- 每个物理页框都用一个页描述符表示
- 页描述符用struct page的结构描述(mm_types.h)
- 所有物理页框的描述符，组织在mem_map的数组中

由于每个struct page结构小于64个字节,页描述符将会占用很大的一段空间

**2.2 node **

物理内存被划分为若干个node.存取时间不等,考虑CPU局部性

Node使用数据结构pg_data_t描述

每个node被划分成若干个zone

** 存储区(Memory Zones)**

划分原因：

一些页框由于自身的物理地址的原因不能被一些任务所使用，例如
：ISA总线的DMA控制器只能对ram的前16M寻址
；在一些具有大容量ram的32位计算机中，CPU不能直接访问所有的物理存储器，因为线性地址空间不够

为了应付这种限制，Linux把具有同样性质的物理内存划分成——区(zones)

每个zone使用struct zone表示

Linux把物理存储器划分为4个区

- ZONE_DMA：包含存储器的“常规”页，通过把它们映射到线性地址空间的3GB以上，内核就可直接访问
- ZONE_DMA32  (未见用）
- ZONE_NORMAL：包含存储器的“常规”页，通过把它们映射到线性地址空间的3GB以上，内核就可直接访问
- ZONE_HIGHMEM：中包含的存储器页面不能由内核直接访问

**2.3 请求页框接口 **

- 分配：
alloc_pages/alloc_page/alloc_pages_node/alloc_pages_current/…/__get_free_pages/__get_free_page/__get_dma_pages/get_zeroed_page
- 释放：
free_pages/__free_pages/free_page/__free_page


**2.4 页框的管理**

内核要为分配一组连续的页框建立一种稳定、高效的分配策略(要解决（外部）碎片问题)

**2.5 避免碎片办法：**

- 利用MMU把一组非连续的物理空闲页框映射到连续的线性地址空间
- 使用一种适当的技术来记录现存的空闲连续页框的情况，以尽量避免为满足对小块的请求而把大块的空闲块进行分割

Linux内核首选第二种方法，**原因**

- 在某些情况下，必须使用连续的页框，如DMA
- 尽量少的修改内核页表


**2.6 buddy算法（伙伴算法，Linux使用）**

把所有空闲页框分组为10（Linux2.6.26为11）个块链表，每个块链表分别包含大小为1，2，4，8，16，32，64，128，256和512个连续的页框

每个块的第一个页框的物理地址是该块大小的整数倍。例如：大小为16个页框的块，其起址是16×4KB的倍数

两个伙伴的大小必须相同，物理地址必须连续
。假定伙伴的大小为b
，那么第一个伙伴的物理地址必须是2×b×4KB对齐

事实上伙伴是通过对大块的物理内存划分获得的

Linux为每个zone使用各自独立的伙伴系统

主要数据结构

- 空闲内存管理数组free_area。
空闲内存按照伙伴管理的方法进行组织；
使用free_area结构

**伙伴**

当两个伙伴都为空闲的时候，就合并成一个更大的块。
该过程将一直进行，直到找不到可以合并的伙伴为止

寻找伙伴

- 给定一个要释放的空闲块
- 找到其伙伴
- 查看其状态：合并 or 不合并

**内存分配**

假设要请求一个大小为128个页框的块(0.5MB)。

- 算法先free_area[7]中检查是否有空闲块（块大小为128个页框）
- 若没有，就到free_area[8]中找一个空闲块（块大小为256个页框）
- 若存在这样的块，内核就把256个页框分成两等份，一半用作满足请求，另一半插入free_area[7]中
- 如果在free_area[8]中也没有空闲块，就继续找free_area[9]中是否有空闲块。	
- 若有，先将512分成伙伴，一个插入free_area[8]中，另一个进一步划分成伙伴，取其一插入free_area[7]中，另一个分配出去
- 如果free_area[9]也没有空闲块，内存不够，返回一个错误信号

**内存的分配与回收**

__free_pages->__free_pages_ok->free_one_page

__alloc_pages->__alloc_pages_internal->get_page_from_freelist->buffered_rmqueue

### 3 内存区管理(memory area)

内核中大量使用各种数据结构，大小从几个字节到几十上百k不等，都取整到2的幂次个页面那是完全不现实的 

**3.1 早期内核解决方法**

**早期内核**的解决方法是提供大小为2,4,8,16,...,131056字节的内存区域 

需要新的内存区域时，内核从伙伴系统申请页面，把它们划分成一个个区域，取一个来满足需求 

如果某个页面中的内存区域都释放了，页面就交回到伙伴系统 

**3.2 Linux2.6.26中**

**SLOB Allocator**: Simple List Of Blocks.
**Slub**：slab的一个变种

slab分配器把内存区看成**对象**

slab分配器把对象**分组**放进高速缓存。

每个**高速缓存**都是同种类型内存对象的一种“储备”

例如当一个文件被打开时，存放相应“打开文件”对象所需的内存是从一个叫做filp(file pointer)的slab分配器的高速缓存中得到的
也就是说每种对象类型对应一个高速缓存

每个高速缓存被分成多个slabs，每个slab由一个或多个连续的页框组成，其中包含一定数目的对象

每个slab有三种状态：全满，半满，全空

- 全满意味着slab中的对象全部已被分配出去
- 全空意味着slab中的对象全部是可用的
- 半满介于两者之间

当内核函数需要一个新的对象时，

- 优先从半满的slab满足这个请求
- 否则从全空的slab中取一个对象满足请求
- 如果没有空的slab则向buddy系统申请页面生成一个新的slab

**普通和专用高速缓存**

每个高速缓存使用kmem_cache表示

普通高速缓存根据大小分配内存

- 26个，2组（一组用于DMA分配，另一组用于常规分配）
- 每组13个，大小从25=32个字节，到217=132017个字节
- 数据结构cache_sizes
- 数组：malloc_sizes

专用高速缓存根据	类型分配


**slab分配器提供的接口**

- 创建专用高速缓存：kmem_cache_create
- 撤销专用高速缓存：kmem_cache_destroy
一般内核撤销一个模块时会调用这个函数撤销属于那个模块的cache类型
- 从专用高速缓冲中分配和释放.
从高速缓存中分配/释放一个内存对象
kmem_cache_alloc/kmem_cache_free
- 从普通高速缓存中分配和释放
**kmalloc/kfree**

slab分配器调用kmem_getpages()来获取一组连续的空闲页框

相应的有kmem_freepages()来释放分配给slab分配器的页框

如果编写的**内核模块有许多创建和释放数据结构**的操作，可以考虑调用前面所述的**slab分配器的接口创建一个高速缓存**
	这样可以大大减少内存的访问时间

### 4 非连续存储区管理

把线性空间映射到一组连续的页框是很好的选择

有时候不得不将线性空间映射到一组不连续的页框.优点：避免碎片

Linux内核有为非连续内存区保留的线性地址空间（VMALLOC_START~VMALLOC_END）

非连续存储区的描述符vm_struct

Vmalloc等分配一个非连续存储区

Vfree释放非连续线性区间

总结：

- alloc_pages/free_page:buddy算法，分配大空间
- kmalloc/kfree：slab，分配数据结构
- Vmalloc/Vfree: 非连续内存区

Others

